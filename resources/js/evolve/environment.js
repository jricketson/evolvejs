// Generated by CoffeeScript 1.4.0
(function() {
  var attack, getSpeciesCallback;

  CORE.environment = {
    _gridX: 80,
    _gridY: 40,
    _timeDelay: 50,
    _instructionsPerCycle: 50,
    _running: false,
    _INITIAL_POPULATION_SIZE_FROM_SERVER: 15,
    _attackerBonus: 0.9,
    _allProcesses: [],
    _runningThreads: [],
    _currentThreadExecuteIndex: 0,
    _grid: [],
    _loopCount: 0,
    stepCount: 0,
    unsentStepCount: 0,
    embodiedEnergy: 5,
    _startTime: 0,
    _stepping: false,
    _slow: false,
    _serialProcessIdSeries: Number(new Date()),
    NORTH: 0,
    EAST: 1,
    SOUTH: 2,
    WEST: 3,
    EVENT_PROCESS_CREATED: "processCreated",
    EVENT_PROCESS_MOVED: "processMoved",
    EVENT_PROCESS_KILLED: "processKilled",
    EVENT_SPECIES_CREATED: "speciesCreated",
    EVENT_SPECIES_EXTINCT: "speciesExtinct",
    VALID_SPECIES: 10,
    SUCCESS_PROXY: 75,
    mutationRate: 1000,
    startTime: 0,
    horizon: 10,
    _getSpeciesCallback: getSpeciesCallback = function(species) {
      var code, ii, population, process, specie;
      population = [];
      if (species.length !== 0) {
        ii = 0;
        while (ii < species.length) {
          code = CORE.assembler.convertStringToCode(species[ii].fields.code);
          species[ii].code = code;
          specie = new CORE.species.Species(species[ii]);
          specie.saved = true;
          CORE.speciesLibrary().addSpeciesFromServer(specie);
          process = new CORE.Process(code.slice(), specie.name);
          process.facing = Math.round(Math.random() * 3);
          population.push(process);
          ii += 1;
        }
      } else {
        population = [new CORE.Process(CORE.ancestor.tree(), "tree"), new CORE.Process(CORE.ancestor.blindAnimal(), "blindAnimal"), new CORE.Process(CORE.ancestor.seeingAnimal(), "seeingAnimal")];
      }
      return this._initialisePopulation(population);
    },
    _initialiseEnvironment: function() {
      this._resizeGrid();
      CORE.data.getSpecies(this._INITIAL_POPULATION_SIZE_FROM_SERVER, $.proxy(this._getSpeciesCallback, this));
      setInterval($.proxy(this._resetCpuRate, this), 500);
      return setInterval($.proxy(this._sendCpuTimeUsed, this), 60000);
    },
    _initialisePopulation: function(population) {
      var ii, _results;
      ii = 0;
      _results = [];
      while (ii < population.length) {
        this._birthProcess(population[ii], null);
        _results.push(ii += 1);
      }
      return _results;
    },
    /*
      adds a process to the queue, also places it in the grid x and y are optional, if not supplied
      will be placed randomly
    */

    _birthProcess: function(process, parentProcess, x, y) {
      var xx, yy;
      if (x !== undefined && y !== undefined) {
        if (!this._grid[x][y]) {
          this._initialiseProcess(process, parentProcess, x, y);
          return true;
        } else {
          return false;
        }
      } else {
        while (true) {
          xx = Math.round(Math.random() * (this._gridX - 1));
          yy = Math.round(Math.random() * (this._gridY - 1));
          if (!this._grid[xx][yy]) {
            this._initialiseProcess(process, parentProcess, xx, yy);
            return true;
          }
        }
      }
      return false;
    },
    _initialiseProcess: function(process, parentProcess, x, y) {
      var species;
      this._grid[x][y] = process;
      process.gridX = x;
      process.gridY = y;
      if (parentProcess !== null) {
        process.facing = parentProcess.facing;
      }
      this._runningThreads.push(process.threads[0]);
      this._allProcesses.push(process);
      species = CORE.speciesLibrary().placeProcess(process, parentProcess);
      jQuery(document).trigger(this.EVENT_PROCESS_CREATED, [process]);
      return species;
    },
    _move: function(process, x, y, wrapped) {
      var attackerWon;
      attackerWon = false;
      if (this._grid[x][y] !== 0) {
        attackerWon = this._attack(process, x, y);
      }
      if (this._grid[x][y] === 0 || attackerWon) {
        this._grid[process.gridX][process.gridY] = 0;
        process.gridX = x;
        process.gridY = y;
        this._grid[x][y] = process;
        return jQuery(document).trigger(this.EVENT_PROCESS_MOVED, [process, wrapped]);
      }
    },
    _removeProcessFromArrays: function(process) {
      var jj, procIndex, thread, threadIndex;
      jj = 0;
      while (jj < process.threads.length) {
        thread = process.threads[jj];
        threadIndex = this._runningThreads.indexOf(thread);
        if (threadIndex > -1) {
          this._runningThreads.splice(threadIndex, 1);
        }
        jj += 1;
      }
      procIndex = this._allProcesses.indexOf(process);
      if (procIndex > -1) {
        return this._allProcesses.splice(procIndex, 1);
      }
    },
    _kill: function(process) {
      process.killMe();
      this._removeProcessFromArrays(process);
      CORE.speciesLibrary().removeProcess(process);
      this._grid[process.gridX][process.gridY] = 0;
      return jQuery(document).trigger(this.EVENT_PROCESS_KILLED, [process]);
    },
    _attack: attack = function(attacker, x, y) {
      var attackerChange, defender, lowCpu;
      defender = this._grid[x][y];
      lowCpu = Math.min(attacker.cputime, defender.cputime);
      if (defender.cputime - lowCpu <= 0) {
        attackerChange = (defender.memory.length * this.embodiedEnergy) - (lowCpu * this._attackerBonus);
        attacker.cputime += attackerChange;
        this._kill(defender);
        return true;
      } else {
        defender.cputime -= lowCpu;
        attacker.cputime -= lowCpu * this._attackerBonus;
        return false;
      }
    },
    _resizeGrid: function() {
      var xx, yy, _results;
      xx = void 0;
      yy = void 0;
      xx = 0;
      _results = [];
      while (xx < this._gridX) {
        yy = 0;
        while (yy < this._gridY) {
          if (!this._grid[xx]) {
            this._grid[xx] = [];
          }
          if (!this._grid[xx][yy]) {
            this._grid[xx][yy] = 0;
          }
          yy += 1;
        }
        _results.push(xx += 1);
      }
      return _results;
    },
    _shineSun: function() {
      var ii, _results;
      ii = 0;
      _results = [];
      while (ii < this._allProcesses.length) {
        this._allProcesses[ii].incrCpuTime(1);
        _results.push(ii += 1);
      }
      return _results;
    },
    _endLoop: function() {
      this._currentThreadExecuteIndex = 0;
      this._loopCount += 1;
      return this._shineSun();
    },
    _runSimulationLoop: function() {
      var start, thread;
      start = (new Date()).getTime();
      while ((new Date()).getTime() - start < this._instructionsPerCycle) {
        this.stepCount++;
        if (this._currentThreadExecuteIndex >= this._runningThreads.length) {
          this._endLoop();
          if (this._stepping || this._slow) {
            break;
          }
        }
        thread = this._runningThreads[this._currentThreadExecuteIndex];
        if (thread.process.dead) {
          this._removeProcessFromArrays(thread.process);
        } else {
          if (thread.step()) {
            this._currentThreadExecuteIndex += 1;
          }
        }
      }
      if (this._running) {
        return setTimeout($.proxy(this._runSimulationLoop, this), this._timeDelay);
      }
    },
    _sendCpuTimeUsed: function() {
      if (this.unsentStepCount > 0) {
        CORE.data.putCpuTime(this.unsentStepCount);
        CORE.displayMessage("{cpucycles}k cpu cycles sent to server".supplant({
          cpucycles: Math.round(this.unsentStepCount / 1000)
        }));
        return this.unsentStepCount = 0;
      }
    },
    _resetCpuRate: function() {
      var secsSinceStart;
      secsSinceStart = (Number(new Date()) - this.getStartTime()) / 1000;
      this.current_rate = Math.round(this.stepCount / secsSinceStart);
      this.resetStartTime();
      this.unsentStepCount += this.stepCount;
      return this.stepCount = 0;
    },
    /*
      starts the environment and runs the simulation
    */

    initialise: function() {
      return this._initialiseEnvironment();
    },
    resetStartTime: function() {
      return this._startTime = Number(new Date());
    },
    start: function() {
      this._running = true;
      this._stepping = false;
      this._slow = false;
      this._runSimulationLoop();
      return this._resetCpuRate();
    },
    slow: function() {
      this._running = true;
      this._stepping = false;
      this._slow = true;
      this._runSimulationLoop();
      return this._resetCpuRate();
    },
    step: function() {
      this._stepping = true;
      return this._runSimulationLoop();
    },
    stop: function() {
      return this._running = false;
    },
    addProcess: function(process, parentProcess, x, y) {
      return this._birthProcess(process, parentProcess, x, y);
    },
    moveProcess: function(process, x, y, wrapped) {
      return this._move(process, x, y, wrapped);
    },
    killProcess: function(process) {
      return this._kill(process);
    },
    getProcessCount: function() {
      return this._allProcesses.length;
    },
    getLoopCount: function() {
      return this._loopCount;
    },
    getGridX: function() {
      return this._gridX;
    },
    getGridY: function() {
      return this._gridY;
    },
    isRunning: function() {
      return this._running;
    },
    getGrid: function() {
      return this._grid;
    },
    getStartTime: function() {
      return this._startTime;
    },
    initialiseGrid: function() {
      return this._resizeGrid();
    },
    getCurrentProcesses: function() {
      return this._allProcesses;
    },
    getSerialCode: function() {
      this._serialProcessIdSeries++;
      return this._serialProcessIdSeries;
    },
    setInstructionsPerCycle: function(value) {
      return this._instructionsPerCycle = Math.round(value);
    },
    getProcessAtPosition: function(x, y) {
      if (this._grid[x][y] !== 0) {
        return this._grid[x][y];
      } else {
        return null;
      }
    },
    checkCanBirth: function(x, y) {
      return !Boolean(this._grid[x][y]);
    },
    addThread: function(thread) {
      return this._runningThreads.push(thread);
    }
  };

}).call(this);
