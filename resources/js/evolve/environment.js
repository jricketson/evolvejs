// Generated by CoffeeScript 1.4.0
(function() {

  CORE.environment = {
    _gridX: 80,
    _gridY: 40,
    _timeDelay: 50,
    _executeMillisecondsPerCycle: 50,
    _running: false,
    _INITIAL_POPULATION_SIZE_FROM_SERVER: 15,
    _attackerBonus: 0.9,
    _allProcesses: [],
    _runningThreads: [],
    _currentThreadExecuteIndex: 0,
    _grid: [],
    _loopCount: 0,
    stepCount: 0,
    unsentStepCount: 0,
    embodiedEnergy: 5,
    _startTime: 0,
    _stepping: false,
    _slow: false,
    _serialProcessIdSeries: Number(new Date()),
    NORTH: 0,
    EAST: 1,
    SOUTH: 2,
    WEST: 3,
    EVENT_PROCESS_CREATED: "processCreated",
    EVENT_PROCESS_MOVED: "processMoved",
    EVENT_PROCESS_KILLED: "processKilled",
    EVENT_SPECIES_CREATED: "speciesCreated",
    EVENT_SPECIES_EXTINCT: "speciesExtinct",
    VALID_SPECIES: 10,
    SUCCESS_PROXY: 75,
    mutationRate: 1000,
    startTime: 0,
    horizon: 10,
    _getSpeciesCallback: function(species) {
      var code, population, process, specie, specieCode;
      if (species.length !== 0) {
        population = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = species.length; _i < _len; _i++) {
            specieCode = species[_i];
            code = CORE.assembler.convertStringToCode(specieCode.fields.code);
            specieCode.code = code;
            specie = new CORE.species.Species(specieCode);
            specie.saved = true;
            CORE.speciesLibrary().addSpeciesFromServer(specie);
            process = new CORE.Process(code.slice(), specie.name);
            process.facing = Math.round(Math.random() * 3);
            _results.push(process);
          }
          return _results;
        })();
      } else {
        population = [new CORE.Process(CORE.ancestor.tree(), "tree"), new CORE.Process(CORE.ancestor.blindAnimal(), "blindAnimal"), new CORE.Process(CORE.ancestor.seeingAnimal(), "seeingAnimal")];
      }
      return this._initialisePopulation(population);
    },
    _initialiseEnvironment: function() {
      this._resizeGrid();
      CORE.data.getSpecies(this._INITIAL_POPULATION_SIZE_FROM_SERVER, $.proxy(this._getSpeciesCallback, this));
      setInterval($.proxy(this._resetCpuRate, this), 500);
      return setInterval($.proxy(this._sendCpuTimeUsed, this), 60000);
    },
    _initialisePopulation: function(population) {
      var p, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = population.length; _i < _len; _i++) {
        p = population[_i];
        _results.push(this._birthProcess(p, null));
      }
      return _results;
    },
    /*
      adds a process to the queue, also places it in the grid x and y are optional, if not supplied
      will be placed randomly
    */

    _birthProcess: function(process, parentProcess, x, y) {
      var xx, yy;
      if ((x != null) && (y != null)) {
        if (!this._grid[x][y]) {
          this._initialiseProcess(process, parentProcess, x, y);
          return true;
        } else {
          return false;
        }
      } else {
        while (true) {
          xx = Math.round(Math.random() * (this._gridX - 1));
          yy = Math.round(Math.random() * (this._gridY - 1));
          if (!this._grid[xx][yy]) {
            this._initialiseProcess(process, parentProcess, xx, yy);
            return true;
          }
        }
      }
      return false;
    },
    _initialiseProcess: function(process, parentProcess, x, y) {
      var species;
      this._grid[x][y] = process;
      process.gridX = x;
      process.gridY = y;
      if (parentProcess !== null) {
        process.facing = parentProcess.facing;
      }
      this._runningThreads.push(process.threads[0]);
      this._allProcesses.push(process);
      species = CORE.speciesLibrary().placeProcess(process, parentProcess);
      jQuery(document).trigger(this.EVENT_PROCESS_CREATED, [process]);
      return species;
    },
    _move: function(process, x, y, wrapped) {
      var attackerWon;
      attackerWon = false;
      if (this._grid[x][y] !== 0) {
        attackerWon = this._attack(process, x, y);
      }
      if (this._grid[x][y] === 0 || attackerWon) {
        this._grid[process.gridX][process.gridY] = 0;
        process.gridX = x;
        process.gridY = y;
        this._grid[x][y] = process;
        return jQuery(document).trigger(this.EVENT_PROCESS_MOVED, [process, wrapped]);
      }
    },
    _removeProcessFromArrays: function(process) {
      var procIndex, thread, threadIndex, _i, _len, _ref;
      _ref = process.threads;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        thread = _ref[_i];
        threadIndex = this._runningThreads.indexOf(thread);
        if (threadIndex > -1) {
          this._runningThreads.splice(threadIndex, 1);
        }
      }
      procIndex = this._allProcesses.indexOf(process);
      if (procIndex > -1) {
        return this._allProcesses.splice(procIndex, 1);
      }
    },
    _kill: function(process) {
      process.killMe();
      this._removeProcessFromArrays(process);
      CORE.speciesLibrary().removeProcess(process);
      this._grid[process.gridX][process.gridY] = 0;
      return jQuery(document).trigger(this.EVENT_PROCESS_KILLED, [process]);
    },
    _attack: function(attacker, x, y) {
      var attackerChange, defender, lowCpu;
      defender = this._grid[x][y];
      lowCpu = Math.min(attacker.cputime, defender.cputime);
      if (defender.cputime - lowCpu <= 0) {
        attackerChange = (defender.memory.length * this.embodiedEnergy) - (lowCpu * this._attackerBonus);
        attacker.cputime += attackerChange;
        this._kill(defender);
        return true;
      } else {
        defender.cputime -= lowCpu;
        attacker.cputime -= lowCpu * this._attackerBonus;
        return false;
      }
    },
    _resizeGrid: function() {
      var xx, yy, _i, _ref, _results;
      _results = [];
      for (xx = _i = 0, _ref = this._gridX; 0 <= _ref ? _i < _ref : _i > _ref; xx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (yy = _j = 0, _ref1 = this._gridY; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; yy = 0 <= _ref1 ? ++_j : --_j) {
            if (!this._grid[xx]) {
              this._grid[xx] = [];
            }
            if (!this._grid[xx][yy]) {
              _results1.push(this._grid[xx][yy] = 0);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    _shineSun: function() {
      var p, _i, _len, _ref, _results;
      _ref = this._allProcesses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.incrCpuTime(1));
      }
      return _results;
    },
    _endLoop: function() {
      this._currentThreadExecuteIndex = 0;
      this._loopCount += 1;
      return this._shineSun();
    },
    _runSimulationLoop: function() {
      var start, thread;
      start = (new Date()).getTime();
      while ((new Date()).getTime() - start < this._executeMillisecondsPerCycle) {
        this.stepCount++;
        if (this._currentThreadExecuteIndex >= this._runningThreads.length) {
          this._endLoop();
          if (this._stepping || this._slow) {
            break;
          }
        }
        thread = this._runningThreads[this._currentThreadExecuteIndex];
        if (thread.process.dead) {
          this._removeProcessFromArrays(thread.process);
        } else {
          if (thread.step()) {
            this._currentThreadExecuteIndex += 1;
          }
        }
      }
      if (this._running) {
        return setTimeout($.proxy(this._runSimulationLoop, this), this._timeDelay);
      }
    },
    _sendCpuTimeUsed: function() {
      if (this.unsentStepCount > 0) {
        CORE.data.putCpuTime(this.unsentStepCount);
        CORE.displayMessage("{cpucycles}k cpu cycles sent to server".supplant({
          cpucycles: Math.round(this.unsentStepCount / 1000)
        }));
        return this.unsentStepCount = 0;
      }
    },
    _resetCpuRate: function() {
      var secsSinceStart;
      secsSinceStart = (Number(new Date()) - this.getStartTime()) / 1000;
      this.current_rate = Math.round(this.stepCount / secsSinceStart);
      this.resetStartTime();
      this.unsentStepCount += this.stepCount;
      return this.stepCount = 0;
    },
    /*
      starts the environment and runs the simulation
    */

    initialise: function() {
      return this._initialiseEnvironment();
    },
    resetStartTime: function() {
      return this._startTime = Number(new Date());
    },
    start: function() {
      var _this = this;
      this._running = true;
      this._stepping = false;
      this._slow = false;
      setTimeout((function() {
        return _this._runSimulationLoop();
      }), 10);
      return this._resetCpuRate();
    },
    slow: function() {
      var _this = this;
      this._running = true;
      this._stepping = false;
      this._slow = true;
      setTimeout((function() {
        return _this._runSimulationLoop();
      }), 10);
      return this._resetCpuRate();
    },
    step: function() {
      var _this = this;
      this._stepping = true;
      return setTimeout((function() {
        return _this._runSimulationLoop();
      }), 10);
    },
    stop: function() {
      return this._running = false;
    },
    addProcess: function(process, parentProcess, x, y) {
      return this._birthProcess(process, parentProcess, x, y);
    },
    moveProcess: function(process, x, y, wrapped) {
      return this._move(process, x, y, wrapped);
    },
    killProcess: function(process) {
      return this._kill(process);
    },
    getProcessCount: function() {
      return this._allProcesses.length;
    },
    getLoopCount: function() {
      return this._loopCount;
    },
    getGridX: function() {
      return this._gridX;
    },
    getGridY: function() {
      return this._gridY;
    },
    isRunning: function() {
      return this._running;
    },
    getGrid: function() {
      return this._grid;
    },
    getStartTime: function() {
      return this._startTime;
    },
    initialiseGrid: function() {
      return this._resizeGrid();
    },
    getCurrentProcesses: function() {
      return this._allProcesses;
    },
    setInstructionsPerCycle: function(value) {
      return this._executeMillisecondsPerCycle = Math.round(value);
    },
    checkCanBirth: function(x, y) {
      return !Boolean(this._grid[x][y]);
    },
    addThread: function(thread) {
      return this._runningThreads.push(thread);
    },
    getSerialCode: function() {
      return this._serialProcessIdSeries++;
    },
    getProcessAtPosition: function(x, y) {
      if (this._grid[x][y] !== 0) {
        return this._grid[x][y];
      } else {
        return null;
      }
    }
  };

}).call(this);
