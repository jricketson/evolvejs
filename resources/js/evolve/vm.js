// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty;

  CORE.vm = {
    _maxOpCode: 27,
    _maxOperand: 10000,
    _OPERAND_MASK: 16777215,
    _searchArray: function(arr, startPt, dirForward, label) {
      if (dirForward) {
        return arr.indexOf(label, startPt);
      } else {
        return arr.lastIndexOf(label, startPt);
      }
    },
    /*
      the search wraps around the end of memory back to the start
    */

    _jmpPtr: function(thread, start, dirForward, label, ptrName) {
      var pos;
      pos = CORE.vm._searchArray(thread.process.memory, start, dirForward, label);
      if (pos === -1) {
        pos = CORE.vm._searchArray(thread.process.memory, (dirForward ? 0 : thread.process.memory.length - 1), dirForward, label);
      }
      if (pos > -1) {
        return thread[ptrName] = pos;
      } else {
        return thread[ptrName] = start + 1;
      }
    },
    _calculateXYForward: function(curX, curY, direction) {
      var newX, newY, wrap;
      newX = curX;
      newY = curY;
      wrap = false;
      switch (direction) {
        case CORE.environment.NORTH:
          newY = curY - 1;
          if (newY < 0) {
            newY = CORE.environment.getGridY() - 1;
            wrap = true;
          }
          break;
        case CORE.environment.EAST:
          newX = curX + 1;
          if (newX > (CORE.environment.getGridX() - 1)) {
            newX = 0;
            wrap = true;
          }
          break;
        case CORE.environment.SOUTH:
          newY = curY + 1;
          if (newY > (CORE.environment.getGridY() - 1)) {
            newY = 0;
            wrap = true;
          }
          break;
        case CORE.environment.WEST:
          newX = curX - 1;
          if (newX < 0) {
            newX = CORE.environment.getGridX() - 1;
            wrap = true;
          }
          break;
        default:
          throw "Direction shouldn't be this value: " + direction;
      }
      return [newX, newY, wrap];
    },
    /*
      standard behaviour of this function is to return a single element from the memory ptr,
      occasionally this function will misbehave (intentionally) and return either: 0 elements
      (remove an element from the copy) 1 element that is a random replacement of the original
      instruction 2 elements, the original plus a random instruction
    */

    _elementsToCopy: function(memory, ptr) {
      var choice, val;
      val = Math.random() * CORE.environment.mutationRate;
      if (val < 1) {
        choice = val * 30;
        if (choice <= 10) {
          return [];
        } else if (choice <= 20) {
          return [CORE.vm._constructRandomOperation()];
        } else {
          return [memory[ptr], CORE.vm._constructRandomOperation()];
        }
      } else {
        return [memory[ptr]];
      }
    },
    _constructRandomOperation: function() {
      return this.encode(Math.round(Math.random() * this._maxOpCode), Math.round(Math.random() * this._maxOperand));
    },
    decode: function(instruction) {
      return [instruction >> 24, instruction & this._OPERAND_MASK];
    },
    encode: function(operator, operand) {
      return (operator << 24) + operand;
    },
    execute: function(thread) {
      var opcode, operand, operator;
      opcode = thread.process.memory[thread.executionPtr] >> 24;
      operand = thread.process.memory[thread.executionPtr] & this._OPERAND_MASK;
      operator = this.instructionCodes[opcode];
      if (operator) {
        operator(thread, operand);
        return this._logOperation(thread, operator, operand);
      } else {
        return this._logInvalidOperation(thread, opcode, operand);
      }
    },
    _logOperation: function(thread, operator, operand) {
      var logtemplate;
      if (thread.process.debug) {
        logtemplate = "{operator} {operand} stack[{stack}], counters[{counters}], shortMem[{shortMem}], ePtr: {ePtr}, rPtr:{rPtr}, wPtr:{wPtr}";
        return $(document).trigger(CORE.EVENT_LOG_MESSAGE, logtemplate.supplant({
          operator: operator.name,
          operand: operand,
          stack: thread.stack.toString(),
          counters: thread.counter.toString(),
          shortMem: thread.shortTermMemory.toString(),
          ePtr: thread.executionPtr,
          rPtr: thread.readPtr,
          wPtr: thread.writePtr
        }));
      }
    },
    _logInvalidOperation: function(thread, opcode, operand) {
      var invalidinstructionLogtemplate;
      if (thread.process.debug) {
        invalidinstructionLogtemplate = "invalid instruction: [{opcode}, {operand}], stack[{stack}]";
        return $(document).trigger(CORE.EVENT_LOG_MESSAGE, invalidinstructionLogtemplate.supplant({
          opcode: opcode.toString(),
          operand: operand.toString(),
          stack: thread.stack.toString()
        }));
      }
    }
  };

  CORE.vm.instructionSet = {
    nop: function(thread, operand) {
      return thread.executionPtr += 1;
    },
    add: function(thread, operand) {
      var a;
      a = thread.stack.pop();
      if (a != null) {
        thread.stack.push(a + operand);
      } else {
        thread.stack.push(operand);
      }
      return thread.executionPtr += 1;
    },
    mult: function(thread, operand) {
      var a;
      a = thread.stack.pop();
      if (a != null) {
        thread.stack.push(a * operand);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    dupTop: function(thread, operand) {
      var a;
      a = thread.stack.pop();
      if (a != null) {
        thread.stack.push(a);
        thread.stack.push(a);
      }
      return thread.executionPtr += 1;
    },
    push: function(thread, operand) {
      thread.stack.push(operand);
      return thread.executionPtr += 1;
    },
    pop: function(thread, operand) {
      var i;
      i = 0;
      while (i < operand) {
        thread.stack.pop();
        i++;
      }
      return thread.executionPtr += 1;
    },
    pushM: function(thread, operand) {
      if (thread.shortTermMemory[operand] != null) {
        thread.stack.push(thread.shortTermMemory[operand]);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    popM: function(thread, operand) {
      if (thread.stack.length > 0) {
        thread.shortTermMemory[operand] = thread.stack.pop();
      } else {
        thread.shortTermMemory[operand] = 0;
      }
      return thread.executionPtr += 1;
    },
    incCounter: function(thread, operand) {
      if (thread.counter[operand] != null) {
        thread.counter[operand] += 1;
      } else {
        thread.counter[operand] = 1;
      }
      return thread.executionPtr += 1;
    },
    resetCounter: function(thread, operand) {
      thread.counter[operand] = 0;
      return thread.executionPtr += 1;
    },
    pushCounter: function(thread, operand) {
      if (thread.counter[operand] != null) {
        thread.stack.push(thread.counter[operand]);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    pushMemSize: function(thread, operand) {
      thread.stack.push(thread.process.memory.length);
      return thread.executionPtr += 1;
    },
    pushCpuTime: function(thread, operand) {
      thread.stack.push(thread.process.cputime);
      return thread.executionPtr += 1;
    },
    pushSpeciesHashcode: function(thread, operand) {
      thread.stack.push(thread.process.species.hashcode);
      return thread.executionPtr += 1;
    },
    pushReadPtr: function(thread, operand) {
      thread.stack.push(thread.readPtr);
      return thread.executionPtr += 1;
    },
    pushWritePtr: function(thread, operand) {
      thread.stack.push(thread.writePtr);
      return thread.executionPtr += 1;
    },
    jmpReadPtrB: function(thread, operand) {
      CORE.vm._jmpPtr(thread, thread.executionPtr, false, operand, "readPtr");
      return thread.executionPtr += 1;
    },
    jmpReadPtrF: function(thread, operand) {
      CORE.vm._jmpPtr(thread, thread.executionPtr, true, operand, "readPtr");
      return thread.executionPtr += 1;
    },
    jmpWritePtrF: function(thread, operand) {
      CORE.vm._jmpPtr(thread, thread.executionPtr, true, operand, "writePtr");
      return thread.executionPtr += 1;
    },
    jmpB: function(thread, operand) {
      return CORE.vm._jmpPtr(thread, thread.executionPtr, false, operand, "executionPtr");
    },
    jmpF: function(thread, operand) {
      return CORE.vm._jmpPtr(thread, thread.executionPtr, true, operand, "executionPtr");
    },
    incReadPtr: function(thread) {
      thread.readPtr += 1;
      return thread.executionPtr += 1;
    },
    incWritePtr: function(thread) {
      thread.writePtr += 1;
      return thread.executionPtr += 1;
    },
    copy: function(thread) {
      var eleToCopy, ii, memoryLength;
      eleToCopy = CORE.vm._elementsToCopy(thread.process.memory, thread.readPtr);
      memoryLength = thread.process.memory.length;
      if (thread.writePtr > memoryLength || thread.readPtr > memoryLength) {
        throw "writeptr or readptr points past the allocated space";
      }
      if (eleToCopy.length === 1) {
        thread.process.spliceMemory(thread.writePtr, 1, eleToCopy[0]);
      } else if (eleToCopy.length === 0) {
        thread.process.spliceMemory(thread.writePtr, 1);
        thread.writePtr -= 1;
      } else {
        thread.process.spliceMemory(thread.writePtr, 1, eleToCopy[0]);
        ii = 1;
        while (ii < eleToCopy.length) {
          thread.process.spliceMemory(thread.writePtr, 0, eleToCopy[ii]);
          thread.writePtr += 1;
          ii += 1;
        }
      }
      return thread.executionPtr += 1;
    },
    lt: function(thread) {
      var a, b;
      a = thread.stack.pop();
      b = thread.stack.pop();
      if ((a != null) && (b != null)) {
        thread.stack.push((b < a) / 1);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    gte: function(thread) {
      var a, b;
      a = thread.stack.pop();
      b = thread.stack.pop();
      if ((a != null) && (b != null)) {
        thread.stack.push((b >= a) / 1);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    eq: function(thread) {
      var a, b;
      a = thread.stack.pop();
      b = thread.stack.pop();
      if ((a != null) && (b != null)) {
        thread.stack.push((b === a) / 1);
      } else {
        thread.stack.push(0);
      }
      return thread.executionPtr += 1;
    },
    ifDo: function(thread, operand) {
      var a;
      a = thread.stack.pop();
      if (a) {
        return thread.executionPtr += 1;
      } else {
        return CORE.vm._jmpPtr(thread, thread.executionPtr, true, operand, "executionPtr");
      }
    },
    ifNotDo: function(thread, operand) {
      var a;
      a = thread.stack.pop();
      if (a) {
        return CORE.vm._jmpPtr(thread, thread.executionPtr, true, operand, "executionPtr");
      } else {
        return thread.executionPtr += 1;
      }
    },
    runThread: function(thread) {
      var newThread;
      newThread = new CORE.Thread(thread.process, "" + thread.process.threads.length);
      newThread.executionPtr = thread.readPtr;
      thread.process.threads.push(newThread);
      CORE.environment.addThread(newThread);
      return thread.executionPtr += 1;
    },
    divide: function(thread) {
      var coords, newProcess, newProcessMemory, success;
      coords = CORE.vm._calculateXYForward(thread.process.gridX, thread.process.gridY, thread.process.facing);
      if (CORE.environment.checkCanBirth(coords[0], coords[1])) {
        newProcessMemory = thread.process.memory.splice(thread.readPtr, thread.writePtr - thread.readPtr);
        newProcess = new CORE.Process(newProcessMemory, thread.process.name);
        newProcess.facing = thread.process.facing;
        CORE.environment.addProcess(newProcess, thread.process, coords[0], coords[1]);
        thread.process.cputime = Math.round(thread.process.cputime / 2);
        newProcess.cputime = thread.process.cputime;
        success = 1;
      } else {
        success = 0;
      }
      thread.stack.push(success);
      thread.executionPtr += 1;
      return newProcess;
    },
    alloc: function(thread, operand) {
      var a, cost, finalLength, ii, success, _i, _ref;
      a = thread.stack.pop();
      success = true;
      if (a !== undefined) {
        cost = CORE.environment.embodiedEnergy * a;
        if (thread.process.cputime > cost) {
          thread.process.decrCpuTime(cost);
          finalLength = thread.process.memory.length + a;
          for (ii = _i = _ref = thread.process.memory.length; _ref <= finalLength ? _i < finalLength : _i > finalLength; ii = _ref <= finalLength ? ++_i : --_i) {
            thread.process.memory[ii] = 0;
          }
        } else {
          success = false;
        }
      }
      thread.stack.push(success);
      return thread.executionPtr += 1;
    },
    /*
      looks forward and puts a structure on the stack
      
      the structure on the stack is distance to next target, or -1 if none seen
      
      cputime budget of target, (only if target seen)
      
      memory size of budget (only if target seen)
    */

    look: function(thread) {
      var coords, found, horizon, i, otherProcess;
      horizon = CORE.environment.horizon;
      coords = [thread.process.gridX, thread.process.gridY];
      found = false;
      i = 0;
      while (i < horizon) {
        coords = CORE.vm._calculateXYForward(coords[0], coords[1], thread.process.facing);
        otherProcess = CORE.environment.getProcessAtPosition(coords[0], coords[1]);
        if (otherProcess !== null) {
          thread.stack.push(otherProcess.species.hashCode);
          thread.stack.push(otherProcess.memory.length);
          thread.stack.push(otherProcess.cputime);
          thread.stack.push(i + 1);
          found = true;
          break;
        }
        i++;
      }
      if (!found) {
        thread.stack.push(0);
        thread.stack.push(0);
        thread.stack.push(0);
        thread.stack.push(-1);
      }
      return thread.executionPtr += 1;
    },
    turnR: function(thread) {
      var facing;
      facing = thread.process.facing;
      facing += 1;
      if (facing > 3) {
        facing = 0;
      }
      thread.process.facing = facing;
      return thread.executionPtr += 1;
    },
    turnL: function(thread) {
      var facing;
      facing = thread.process.facing;
      facing -= 1;
      if (facing < 0) {
        facing = 3;
      }
      thread.process.facing = facing;
      return thread.executionPtr += 1;
    },
    /*
      moves one space straight ahead, if the path is not blocked.
    */

    move: function(thread) {
      var coords;
      coords = CORE.vm._calculateXYForward(thread.process.gridX, thread.process.gridY, thread.process.facing);
      CORE.environment.moveProcess(thread.process, coords[0], coords[1], coords[2]);
      return thread.executionPtr += 1;
    },
    sleep: function(thread, operand) {
      thread.sleepCycles = operand;
      return thread.executionPtr += 1;
    },
    setSpeed: function(thread, operand) {
      thread.speed = operand;
      return thread.executionPtr += 1;
    }
  };

  CORE.vm.instructionCodes = {
    0: CORE.vm.instructionSet.nop,
    1: CORE.vm.instructionSet.add,
    29: CORE.vm.instructionSet.mult,
    2: CORE.vm.instructionSet.push,
    30: CORE.vm.instructionSet.pop,
    34: CORE.vm.instructionSet.dupTop,
    3: CORE.vm.instructionSet.pushM,
    4: CORE.vm.instructionSet.popM,
    31: CORE.vm.instructionSet.incCounter,
    32: CORE.vm.instructionSet.resetCounter,
    33: CORE.vm.instructionSet.pushCounter,
    5: CORE.vm.instructionSet.pushMemSize,
    27: CORE.vm.instructionSet.pushCpuTime,
    37: CORE.vm.instructionSet.pushSpeciesHashcode,
    6: CORE.vm.instructionSet.pushWritePtr,
    7: CORE.vm.instructionSet.pushReadPtr,
    8: CORE.vm.instructionSet.jmpReadPtrB,
    9: CORE.vm.instructionSet.jmpReadPtrF,
    10: CORE.vm.instructionSet.incReadPtr,
    12: CORE.vm.instructionSet.jmpWritePtrF,
    13: CORE.vm.instructionSet.incWritePtr,
    14: CORE.vm.instructionSet.jmpB,
    28: CORE.vm.instructionSet.jmpF,
    15: CORE.vm.instructionSet.copy,
    16: CORE.vm.instructionSet.lt,
    17: CORE.vm.instructionSet.gte,
    18: CORE.vm.instructionSet.ifDo,
    26: CORE.vm.instructionSet.ifNotDo,
    19: CORE.vm.instructionSet.runThread,
    20: CORE.vm.instructionSet.alloc,
    21: CORE.vm.instructionSet.divide,
    22: CORE.vm.instructionSet.look,
    23: CORE.vm.instructionSet.turnR,
    36: CORE.vm.instructionSet.turnL,
    24: CORE.vm.instructionSet.move,
    25: CORE.vm.instructionSet.sleep,
    35: CORE.vm.instructionSet.setSpeed,
    36: CORE.vm.instructionSet.eq
  };

  CORE.vm.getOperatorName = function(operator) {
    var fn, name, _ref;
    _ref = CORE.vm.instructionSet;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      fn = _ref[name];
      if (operator === fn) {
        return name;
      }
    }
  };

  CORE.vm.codeInstructions = (function() {
    var code, instruction, name, nameToCode, _ref;
    nameToCode = {};
    _ref = CORE.vm.instructionCodes;
    for (code in _ref) {
      if (!__hasProp.call(_ref, code)) continue;
      instruction = _ref[code];
      name = CORE.vm.getOperatorName(instruction);
      nameToCode[name] = Number(code);
    }
    return nameToCode;
  })();

}).call(this);
