// Generated by CoffeeScript 1.4.0
(function() {
  var Process, Thread, decrCpuTime, getState, threadStep;

  CORE.Process = Process = function(memory, name) {
    this.memory = memory;
    this.threads = [];
    this.cputime = 3000;
    this.gridX = 0;
    this.gridY = 0;
    this.facing = 0;
    this.dead = false;
    this.name = name;
    this.species = "";
    this.age = 0;
    this.threads.push(new CORE.Thread(this, "0"));
    return this.id = CORE.environment.getSerialCode();
  };

  CORE.Process.prototype.spliceMemory = function(position, elementCount, element) {
    return this.memory.splice(position, elementCount, element);
  };

  /*
  decrements the processes cputime, if the available cputime ever drops below
  0, the process is killed
  */


  CORE.Process.prototype.decrCpuTime = decrCpuTime = function(decrement) {
    this.cputime -= decrement;
    if (this.cputime < 0) {
      return CORE.environment.killProcess(this);
    }
  };

  CORE.Process.prototype.killMe = function() {
    var i;
    i = 0;
    while (i < this.threads.length) {
      this.threads[i].killMe();
      i++;
    }
    return this.dead = true;
  };

  CORE.Process.prototype.incrCpuTime = function(increment) {
    return this.cputime += increment;
  };

  CORE.Process.prototype.getHashCode = function() {
    return CORE.util.getHashCode(this.memory);
  };

  CORE.Process.prototype.getState = getState = function() {
    var i, state;
    state = [];
    i = 0;
    while (i < this.threads.length) {
      state.push(this.threads[i].getState());
      i++;
    }
    return state;
  };

  CORE.SparseArray = function() {};

  CORE.SparseArray.prototype.toString = function() {
    var i, result;
    result = [];
    for (i in this) {
      if (this.hasOwnProperty(i)) {
        result.push(i + "[" + this[i] + "]");
      }
    }
    return result.join(",");
  };

  CORE.Thread = Thread = function(process, name) {
    this.process = process;
    this.stack = [];
    this.counter = new CORE.SparseArray();
    this.shortTermMemory = new CORE.SparseArray();
    this.executionPtr = 0;
    this.readPtr = 0;
    this.writePtr = 0;
    this.speed = 1;
    this.sleepCycles = 0;
    return this.name = name;
  };

  CORE.Thread._maxStackSize = 8;

  CORE.Thread.prototype.step = threadStep = function() {
    var ii;
    if (this === this.process.threads[0]) {
      this.process.age += 1;
    }
    if (this.sleepCycles > 0) {
      this.sleepCycles -= 1;
      return !this.process.dead;
    }
    ii = 0;
    while (ii < this.speed) {
      if (this.executionPtr > this.process.memory.length - 1) {
        CORE.environment.killProcess(this.process);
        return !this.process.dead;
      }
      try {
        CORE.vm.execute(this);
      } catch (err) {
        if (this.process !== null) {
          $.debug("(" + this.process.name + ") process threw an error: ", this.process);
        }
        $.debug(err);
        CORE.environment.killProcess(this.process);
      }
      if (!this.process.dead) {
        this.process.decrCpuTime(this.speed * this.speed);
        if (this.stack.length > CORE.Thread._maxStackSize && !this.process.dead) {
          this.stack.splice(CORE.Thread._maxStackSize, this.stack.length - CORE.Thread._maxStackSize);
          this.process.decrCpuTime(this.speed * this.speed);
        }
      }
      return !this.process.dead;
      ii += 1;
    }
  };

  CORE.Thread.prototype.getState = getState = function() {
    return [this.stack, this.process.memory.length, this.executionPtr, this.readPtr, this.writePtr];
  };

  CORE.Thread.prototype.killMe = function() {};

}).call(this);
